#include <cstdio>
#include <map>
#include <list>

using namespace std;

typedef struct {
  int c, f;
} edata;

typedef struct {
  bool v;
} vdata;

multimap< int, pair<int, edata> > edges;
map< int, vdata > vertex;

list< int > rPath;
int dfs(int s, int t, int minRC){ //target and min Residual Capacity
  if(s == t){
    if(minRC > 0){
      rPath.push_front( s );
      return minRC;
    }else{
      return 0;
    }
  }else{
    int minimum = 0;
    pair< multimap< int, pair<int, edata> >::const_iterator, multimap< int, pair<int, edata> >::const_iterator > nb;
    nb = edges.equal_range(s);
    while(nb.first != nb.second && minimum == 0){
      minimum = dfs(nb.first->first, t, min(minRC, (nb.first->second).second.f));
      nb.first++;
    }
    if(minimum!=0){
      rPath.push_front(s);
    }
    return minimum;
  }
}

multimap< int, pair<int, edata> >::iterator findEdge(int u, int v){
  pair< multimap< int, pair<int, edata> >::iterator, multimap< int, pair<int, edata> >::iterator > ls;
  ls = edges.equal_range(u);

  while(ls.first != ls.second && (ls.first->second).first != v) ls.first++;
  
  return ls.first;
}

void ff(int s, int t){
  int minRC, u, v;
  list< int >::const_iterator iter;
  multimap< int, pair<int, edata> >::iterator e;
  
  e = edges.begin();
  while(e!=edges.end()){
    e->second.second.f = 0;
    e++;
  }
  
  rPath.clear();
  minRC = dfs(s, t, 0);

  while(minRC > 0){

    u = *iter; iter++;
    v = *iter; iter++;

    rPath.clear();
    minRC = dfs(s, t, 0);
  }
}

int main(){
  return 0;
}
